### 参考
- [设计模式文档](http://www.runoob.com/design-pattern/design-pattern-intro.html)
- 


## 读书笔记
- 第1章 单一职责原则
- 第2章 里氏替换原则
- 第3章 依赖倒置原则
- 第4章 接口隔离原则
- 第5章 迪米特法则
- 第6章 开闭原则

#### 单一职责原则 
- Single Responsibility Principle
- 应该有且仅有一个原因引起类的变更。
- 接口、类、方法，尽量只处理一个任务。
- 对于接口,我们在设计的时候一定要做到单一,但是对于实现类就需要多方面考虑了。
- 生搬硬套单一职责原则会引起类的剧增,给维护带来非常多的麻烦,而且过分细分类的职责也会人为地增加系统的复杂性。本来一个类可以实现的行为硬要拆成两个类,然后再使用聚合或组合的方式耦合在一起,人为制造了系统的复杂性。所以原则是死的,人是活的,这句话很有道理。


#### 里氏替换原则
- 父类出现的地方可以完全替换成子类
- 所有引用基类的地方必须能透明地使用其子类的对象。


#### 依赖倒置原则
更加精简的定义就是“==面向接口编程==”——OOD(Object-OrientedDesign,面向对象设计)的精髓之一。依赖倒置原则在Java语言中的表现就是:
- 模块间的依赖通过抽象发生,实现类之间不发生直接的依赖关系,其依赖关系是通过接口或抽象类产生的;
- 接口或抽象类不依赖于实现类;
- 实现类依赖接口或抽象类。

#### 接口隔离原则
把一个臃肿的接口变更为两个独立的接口
- 接口要尽量小
- 接口要高内聚，高内聚就是提高接口、类、模块的处理能力,减少对外的交互。
- 定制服务，只提供访问者需要的方法
- 接口设计是有限度的，接口的设计粒度越小,系统越灵活,但是,灵活的同时也带来了结构的复杂化

#### 迪米特法则
- 一个对象应该对其他对象有最少的了解。（==高内聚低耦合==：减少不必要的对外方法，减少不必要的依赖）
- 一个类只和朋友交流,不与陌生类交流。,降低了系统间的耦合,提高了系统的健壮性。与类之间的关系是建立在类间的,而不是方法间,因此一个方法尽量不引入一个类中不存在的对象。
- 一个类公开的public属性或方法越多,修改时涉及的面也就越大,变更引起的风险扩散也就越大。因此,为了保持朋友类间的距离,在设计时需要反复衡量:是否还可以再减少public方法和属性,是否可以修改为private、package-private(包类型,在类、方法、变量前不加访问权限,则默认为包类型)、protected等访问权限,是否可以加上final关键字等。
- 迪米特法则的核心观念就是类间解耦,弱耦合,只有弱耦合了以后,类的复用率才可以提高。其要求的结果就是产生了大量的中转或跳转类,导致系统的复杂性提高,同时也为维护带来了难度。读者在采用迪米特法则时需要反复权衡,既做到让结构清晰,又做到高内聚低耦合。

#### 开闭原则
- 一个软件实体如类、模块和函数应该对扩展开放,对修改关闭。
- 其含义是：通过扩展来实现变化,而不是通过修改已有的代码来实现变化。

## 实例
#### 单例
为了达到线程安全，又能提高代码执行效率，我们这里可以采用DCL的双检查锁机制来完成。
```java
    private static volatile RecognizerManager instance = null;
    /**
    * 单例（双检查锁机制）
    * @return
    */
    public static RecognizerManager getInstance() {
        if (instance == null) {
            synchronized (RecognizerManager.class) {
            if (instance == null) {
                instance = new RecognizerManager();
            }
        }
    }
    return instance;
    }
```


#### 工厂方法
- [java三种工厂模式](https://www.cnblogs.com/zailushang1996/p/8601808.html)
- 定义一个用于创建对象的接口,让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。
- 应用：遥控界面，抽象遥控类（接口）定义了遥控界面的共同方法，子类中具体化这些方法。然后遥控界面工厂调用这些不同的工厂去产生遥控界面对象。
- 工厂方法模式的扩展性非常优秀。在增加产品类的情况下,只要适当地修改具体的工厂类或扩展一个工厂类,就可以完成“拥抱变化”。
- 工厂方法模式是典型的解耦框架。高层模块值需要知道产品的抽象类,其他的实现类都不用关心,符合迪米特法则,我不需要的就不要去交流;也符合依赖倒置原则,只依赖产品类的抽象;当然也符合里氏替换原则,使用产品子类替换产品父类。
- 简单工厂/静态工厂，是工厂方法的简化，使用一个静态类来生产不同的对象。
#### 抽象工厂
- 创建一组相关或相互依赖的对象提供一个接口,而且无须指定它们的具体类。




